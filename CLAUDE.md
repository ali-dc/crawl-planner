# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a pub crawl route planner that optimizes paths through multiple pubs from a starting location to an ending location. It uses OSRM (Open Source Routing Machine) for walking distance calculations and employs optimization algorithms to find routes with good balance between distance efficiency and uniform spacing between stops.

## Project Structure

The codebase is organized into two main directories:

- **`backend/`**: Python FastAPI application
  - `app.py`: Main FastAPI application with all endpoints
  - `planner.py`: Core route optimization logic
  - `osrm_client.py`: HTTP client for OSRM service
  - `api_schemas.py`: Pydantic models for request/response validation
  - `parse.py`: Raw data parser (one-off script)
  - `precompute_distances.py`: Distance matrix precomputation (one-off script)
  - `data.json`: Structured pub data (generated by `parse.py`)
  - `pub_distances.pkl`: Precomputed distance matrix (generated by `precompute_distances.py`)
  - `pyproject.toml`: Python dependencies and project metadata

- **`frontend/`**: React + TypeScript + Vite application
  - `src/App.tsx`: Main application component
  - `src/components/`: React components (map, form, results, etc.)
  - `src/services/`: API client and data service functions
  - `src/hooks/`: Custom React hooks
  - `src/utils/`: Utility functions
  - `src/theme.ts`: Material-UI theme configuration
  - `package.json`: Node.js dependencies and scripts

- **`osrm-data/`**: OSRM map data for Bristol (included in container)

- **Docker & Deployment**:
  - `Dockerfile`: Container image for FastAPI backend
  - `Dockerfile.nginx`: Nginx reverse proxy (production)
  - `docker-compose.yml`: Development setup (FastAPI + OSRM)
  - `docker-compose.prod.yml`: Production setup (FastAPI + OSRM + Nginx + SSL)

## Architecture

### Data Pipeline

1. **Raw Data Parsing** (`parse.py`):
   - Loads raw pub data from `raw.data` (JSON format with obfuscated field names like `_18`, `_20`, etc.)
   - Extracts essential fields: pub ID, name, address, latitude, longitude
   - Outputs structured pub data to `data.json`
   - Run: `python parse.py`

2. **Distance Precomputation** (`precompute_distances.py`):
   - Loads pub coordinates from `data.json`
   - Queries OSRM's table endpoint to build an n×n distance matrix for all pubs
   - Uses batching (MAX_BATCH_SIZE=10) to handle OSRM's endpoint limits
   - Pickles the distance matrix and metadata to `pub_distances.pkl`
   - Run: `python precompute_distances.py` (requires OSRM server running)

3. **Route Planning** (`planner.py`):
   - Core `PubCrawlPlanner` class that operates on precomputed distances
   - Takes a start point, end point, number of pubs, and uniformity preference
   - Returns optimized routes with pub IDs, total distance, and estimated time

### Route Optimization Strategy

The planner uses a multi-phase approach:

1. **Candidate Selection**: Filters pubs that lie roughly along the corridor from start to end using:
   - `project_onto_line()`: Maps each pub's position onto the start-end line (0-1 scale)
   - `perpendicular_distance()`: Calculates deviation from the path
   - Scores pubs to favor those near the path

2. **Distance Precomputation**: Batch-fetches distances from start/end to all candidates using OSRM

3. **Route Optimization**:
   - **For k ≤ 8 pubs**: Uses sampling + 2-opt (`sample_and_optimize`)
     - Samples 1000 random combinations of k pubs
     - Applies nearest-neighbor ordering + 2-opt local optimization to each
     - Selects the best route
   - **For k > 8 pubs**: Uses greedy with 2-opt (`greedy_with_improvement`)
     - Greedily selects pubs based on distance-to-pub + estimated-distance-to-end
     - Applies 2-opt improvement afterward

4. **Evaluation**: Routes are scored as:
   - `total_distance + uniformity_weight * std_dev_of_segments`
   - Higher `uniformity_weight` (e.g., 0.99) favors evenly-spaced stops

### External Service Integration

**OSRM Client** (`osrm_client.py`):
- Wraps HTTP calls to a local OSRM server (default: `http://localhost:5005`)
- Key methods:
  - `get_distance_matrix()`: Batch query for multiple pairs (most efficient)
  - `get_distances_from_point()`: One-to-many distances
  - `get_distances_to_point()`: Many-to-one distances
  - `get_directions()`: Turn-by-turn navigation with geometry
- **Important**: All coordinates use (longitude, latitude) order, not (lat, lon)

### Data Formats

**Pub Coordinates**: Stored as (longitude, latitude) tuples throughout. This is critical for OSRM compatibility.

**Distance Matrix**: n×n numpy array (float32) indexed by pub indices. Entry `[i][j]` is walking distance in meters from pub i to pub j.

## Quick Start

### Option 1: Full-Stack Development (Recommended)

Start both backend API and frontend development server together:

```bash
# Terminal 1: Start OSRM and FastAPI backend
docker-compose up osrm app

# Terminal 2: Start frontend dev server (from frontend directory)
cd frontend
npm install  # First time only
npm run dev

# Frontend available at http://localhost:5173 (proxies API calls to http://localhost:8000)
# Backend API at http://localhost:8000
# API docs at http://localhost:8000/docs
```

### Option 2: Docker Compose (All Services)

Run everything in containers:

```bash
# Development setup
docker-compose up -d

# Application available at http://localhost:8000
# OSRM accessible at http://localhost:5005
# Check logs: docker-compose logs -f app
```

### Option 3: Backend Only (Quick Testing)

For working on the backend without frontend:

```bash
# Install Python dependencies (requires uv)
cd backend
uv install

# Start OSRM in Docker
docker-compose up -d osrm

# Run FastAPI server
uv run app.py

# Server at http://localhost:8000, docs at http://localhost:8000/docs
```

## Development Commands

### Backend (Python / FastAPI)

**Running the server:**
```bash
cd backend
uv run app.py

# Server runs on http://localhost:8000
# Interactive API docs: http://localhost:8000/docs
# OpenAPI schema: http://localhost:8000/openapi.json
```

**Type checking and linting:**
```bash
cd backend
uv run mypy *.py  # Type check with mypy
```

**Data pipeline scripts:**
```bash
cd backend

# Parse raw pub data (from raw.data) into structured format
uv run parse.py

# Precompute distance matrix (requires OSRM running)
# This creates pub_distances.pkl and takes several minutes
uv run precompute_distances.py
```

**Testing the API directly:**
```bash
# Check API health
curl http://localhost:8000/health

# List available pubs (paginated)
curl http://localhost:8000/pubs?skip=0&limit=10

# Get details for a specific pub
curl http://localhost:8000/pubs/{pub_id}

# Plan a route
curl -X POST http://localhost:8000/plan \
  -H "Content-Type: application/json" \
  -d '{
    "start_point": {"longitude": -2.6, "latitude": 51.4},
    "end_point": {"longitude": -2.5, "latitude": 51.5},
    "num_pubs": 5,
    "uniformity_weight": 0.5
  }'

# Trigger distance precomputation (long-running)
curl -X POST http://localhost:8000/precompute

# Check precomputation status
curl http://localhost:8000/status
```

### Frontend (React / TypeScript / Vite)

**Development:**
```bash
cd frontend

npm install     # Install dependencies
npm run dev     # Start dev server on http://localhost:5173
npm run build   # Build for production (outputs to dist/)
npm run preview # Preview production build locally
```

**Code quality:**
```bash
cd frontend

npm run lint       # Run ESLint
npm run type-check # Type check with TypeScript (tsc)
```

**Frontend dev server proxying:**
The Vite dev server automatically proxies API requests to `http://localhost:8000`. All paths under `/health`, `/pubs`, `/plan`, `/directions`, `/precompute`, `/parse`, and `/status` are forwarded to the backend. This allows development without CORS issues.

### OSRM Server

**Start the OSRM routing backend (required for distance calculations):**
```bash
docker-compose up -d osrm

# Verify it's running
curl http://localhost:5005/route/v1/foot/-2.6,51.4;-2.5,51.4

# View logs
docker-compose logs -f osrm
```

## External Dependencies

### Backend (Python)

**Core dependencies** (specified in `backend/pyproject.toml`):
- **numpy**: Numerical operations on distance matrices
- **requests**: HTTP calls to OSRM
- **tqdm**: Progress bars during precomputation
- **fastapi**: Web framework for the API
- **uvicorn**: ASGI server to run FastAPI
- **pydantic**: Request/response validation and serialization
- **python-dotenv**: Load environment variables from `.env`

Install with: `cd backend && uv install` (uses uv package manager)

### Frontend (Node.js)

**Main dependencies** (from `frontend/package.json`):
- **React & React DOM**: UI framework
- **TypeScript**: Type safety
- **Vite**: Build tool and dev server
- **Material-UI**: Component library
- **MapLibre GL**: Interactive maps for route visualization
- **React Icons**: Icon library

**Development dependencies**:
- **ESLint**: Code quality and style checking
- **TypeScript compiler**: Type checking

Install with: `cd frontend && npm install`

### System Requirements

- **Node.js** >= 18.x (for frontend development)
- **Python** >= 3.14 (for backend)
- **Docker** & **Docker Compose** (for OSRM and containerized deployments)
- **uv** package manager (lightweight Python package manager, recommended for backend)

## Docker Setup

### Development (docker-compose.yml)

Standard development setup with FastAPI and OSRM:

```bash
# Start OSRM and FastAPI backend
docker-compose up -d osrm app

# Start just OSRM (if you want to run the app locally)
docker-compose up -d osrm

# View logs
docker-compose logs -f app
docker-compose logs -f osrm

# Stop services
docker-compose down

# Rebuild the app image after code changes
docker-compose up -d --build app
```

**Services**:
- **osrm**: OSRM routing backend (port 5005, internal)
  - Routes requests for walking distance calculations
  - Map data from `osrm-data/` directory
  - Auto-restarts on failure

- **app**: FastAPI application (port 8000)
  - Serves REST API and health checks
  - Connects to OSRM via internal network
  - Has healthcheck configured (checks `/health` endpoint)
  - Auto-restarts on crash or unhealthy status

### Production (docker-compose.prod.yml)

Production setup with FastAPI, OSRM, and Nginx with SSL/TLS:

```bash
# Start all production services
docker-compose -f docker-compose.prod.yml up -d

# View logs
docker-compose -f docker-compose.prod.yml logs -f nginx
docker-compose -f docker-compose.prod.yml logs -f app

# Stop services
docker-compose -f docker-compose.prod.yml down
```

**Additional services**:
- **nginx**: Reverse proxy and web server (port 80, 443)
  - Serves static frontend files (dist/)
  - Proxies API calls to FastAPI backend
  - Handles SSL/TLS termination
  - Auto-restarts on crash or unhealthy status

### Data Persistence

Data files are mounted as volumes in both `docker-compose.yml` and `docker-compose.prod.yml`:
- `backend/data.json`: Structured pub data (will be copied into container if it exists)
- `backend/pub_distances.pkl`: Precomputed distance matrix (will be copied into container if it exists)
- `backend/raw.data`: Raw pub data file (optional, for parsing)

To regenerate data, use the API endpoints:
- `POST /parse`: Parse raw data into data.json
- `POST /precompute`: Precompute distance matrix (long-running)

### Startup Flow

When the app container starts (via `entrypoint.sh`):
1. FastAPI server is launched in the background
2. `init-precompute.sh` is executed to ensure the distance matrix exists
3. If `pub_distances.pkl` doesn't exist, precomputation is triggered automatically
4. Once initialization completes, the app is ready to handle requests

## Key Design Decisions

1. **Two-phase distance retrieval**:
   - Precomputed pub-to-pub matrix (fast, reusable)
   - Runtime OSRM calls for start/end to pubs (necessary because start/end can be arbitrary coordinates)

2. **Optimization threshold at 8 pubs**:
   - Below 8: Exhaustive sampling with local optimization is feasible
   - Above 8: Greedy approach with local polish is more practical

3. **Uniformity weighting**:
   - Optional parameter allows trading distance optimality for more even spacing
   - Useful for social crawls where consistent rest intervals matter

## API Architecture

The FastAPI implementation (`app.py`) wraps the core planner logic with HTTP endpoints. The app initializes via a `PubCrawlPlannerApp` class that manages lifecycle, endpoints, and state.

### Global State Management
- `planner`: Singleton `PubCrawlPlanner` instance initialized on startup from `pub_distances.pkl`
- `pubs_data`: In-memory list of `PubModel` objects loaded from `data.json`
- `osrm_client`: Singleton `OSRMClient` for runtime distance queries and directions
- `precompute_in_progress`: Boolean flag to prevent concurrent precomputation requests

### API Endpoints

**Data & Planning**:
- `GET /health`: Check API status and OSRM availability
- `GET /pubs`: List all pubs (supports pagination with `skip` and `limit` query params)
- `GET /pubs/{pub_id}`: Get details for a specific pub
- `POST /plan`: Plan an optimized pub crawl route (main endpoint)
- `POST /directions`: Get turn-by-turn directions for a route
- `GET /status`: Check precomputation status

**Administration**:
- `POST /precompute`: Trigger distance matrix precomputation (long-running, returns job status)
- `POST /parse`: Parse raw pub data from `raw.data` into `data.json`

**Frontend**:
- `GET /`: Serve `index.html`
- `GET /styles.css`: Serve stylesheet
- `GET /app.js`: Serve frontend JavaScript
- `GET /static/*`: Serve static files (if directory exists)

### Request Lifecycle
1. Client sends POST to `/plan` with `PlanCrawlRequest` (start point, end point, num_pubs, uniformity_weight)
2. Pydantic models validate and parse the JSON request
3. Planner computes route using cached distance matrix and OSRM for start/end distances
4. Response includes route indices, pub details, distances, time estimates, and optional leg-by-leg directions
5. FastAPI serializes response to JSON with snake_case field names

### Coordinate Handling in API
- Clients send coordinates as `CoordinateModel` objects with `longitude` and `latitude` fields
- Stored as tuples in (longitude, latitude) order throughout for OSRM compatibility
- Directions include GeoJSON geometry for route visualization

## Code Style Notes

- Coordinates are consistently (longitude, latitude)
- The planner uses both pub indices (for matrix lookups) and 'start'/'end' markers for start/end points
- Distance values are in meters
- Time estimates assume ~80 meters/minute walking speed
- API responses use snake_case field names (Pydantic default)

## Important Implementation Details

### Distance Matrix Caching
The precomputed distance matrix (`pub_distances.pkl`) contains:
- `distances`: numpy float32 array of shape (n_pubs, n_pubs)
- `pub_coords`: List of (longitude, latitude) tuples for each pub
- `pub_ids`: List of pub ID strings matching the order of the matrix

This matrix is loaded at API startup. If it doesn't exist, the `/precompute` endpoint must be called first (requires OSRM running). The distance values are in meters.

### OSRM Integration Points
- **Precomputation**: Queries all pub-to-pub distances in batches (MAX_BATCH_SIZE=10)
- **Runtime**: Called for start→all_candidates and all_candidates→end distances
- **Directions**: Called to get turn-by-turn routing when `include_directions=true` in `/plan` request
- Coordinate order critical: Always (longitude, latitude) for OSRM endpoints

### Optimization Algorithm Selection
The route optimization strategy depends on the number of pubs:
- **k ≤ 8 pubs**: Full combinatorial search with sampling (1000 samples, 2-opt polish)
  - Finding global optima is feasible; explores distance + uniformity trade-off
- **k > 8 pubs**: Greedy selection with 2-opt improvement
  - Speed required; uses heuristic distance-to-pub + estimated-distance-to-end scoring

The threshold of 8 pubs balances exploration time with solution quality. Adjust in `planner.py:plan_crawl()` if needed.

### Pub Data Structure
Each pub (`PubModel`) has:
- `id`: Unique identifier (string)
- `name`: Display name
- `address`: Street address
- `longitude`, `latitude`: Coordinates for routing
- (optionally) `category`, `description`, etc. from raw data

The `data.json` file stores all pubs as a JSON array. Raw data parsing (`parse.py`) extracts only essential routing fields from obfuscated `raw.data`.

## Frontend Architecture

The frontend is a React + TypeScript application built with Vite. It provides an interactive UI for planning pub crawl routes.

### Key Components

**Main Application** (`src/App.tsx`):
- Top-level React component that manages application state
- Orchestrates the map, form, results, and UI layout

**Components** (`src/components/`):
- **Map components**: Interactive MapLibre GL maps for showing route visualization
- **Form components**: Inputs for start location, end location, number of pubs, and uniformity preference
- **Results components**: Display planned routes with distances, times, and pub details
- **Dialog/Modal components**: Confirmation and informational dialogs

**Services** (`src/services/`):
- **API client**: Handles HTTP calls to the FastAPI backend
- **Distance/routing services**: Wrapper functions for route planning, directions, and pub listing

**Hooks** (`src/hooks/`):
- Custom React hooks for state management, API calls, and side effects
- Encapsulate reusable logic

**Utilities** (`src/utils/`):
- Helper functions for calculations, formatting, and data transformation
- Map utilities for coordinate handling

**Theme & Styling** (`src/theme.ts`):
- Material-UI theme configuration
- Global color, typography, and spacing definitions
- Emotion CSS-in-JS for component styling

### Key Design Patterns

- **State Management**: Uses React hooks (useState, useEffect, useReducer) for component state
- **API Integration**: Axios or Fetch API via custom service functions
- **Error Handling**: Toast notifications or dialog modals for user feedback
- **Responsive Design**: Material-UI components and CSS media queries for mobile/tablet/desktop layouts
- **Map Rendering**: MapLibre GL for displaying Bristol map with route polylines and pub markers
