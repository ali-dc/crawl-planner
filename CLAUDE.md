# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a pub crawl route planner that optimizes paths through multiple pubs from a starting location to an ending location. It uses OSRM (Open Source Routing Machine) for walking distance calculations and employs optimization algorithms to find routes with good balance between distance efficiency and uniform spacing between stops.

## Project Structure

The codebase is organized into two main directories:

- **`backend/`**: Python FastAPI application
  - `app.py`: Main FastAPI application with all endpoints
  - `planner.py`: Core route optimization logic
  - `osrm_client.py`: HTTP client for OSRM service
  - `api_schemas.py`: Pydantic models for request/response validation
  - `parse.py`: Raw data parser (one-off script)
  - `precompute_distances.py`: Distance matrix precomputation (one-off script)
  - `polyline_utils.py`: Polyline encoding/decoding utilities for efficient geometry transmission
  - `pyproject.toml`: Python dependencies and project metadata

- **`data/`**: Data directory (shared between backend and Docker)
  - `data.json`: Structured pub data (generated by `parse.py`)
  - `pub_distances.pkl`: Precomputed distance matrix (generated by `precompute_distances.py`)
  - `raw.data`: Raw pub data file (optional, for manual parsing)

- **`frontend/`**: React + TypeScript + Vite application
  - `src/App.tsx`: Main application component
  - `src/components/`: React components (map, form, results, etc.)
  - `src/services/`: API client and data service functions
  - `src/hooks/`: Custom React hooks
  - `src/utils/`: Utility functions
  - `src/theme.ts`: Material-UI theme configuration
  - `package.json`: Node.js dependencies and scripts

- **`osrm-data/`**: OSRM map data for Bristol (included in container)

- **Docker & Deployment**:
  - `Dockerfile`: Container image for FastAPI backend
  - `Dockerfile.nginx`: Nginx reverse proxy (production)
  - `docker-compose.yml`: Development setup (FastAPI + OSRM)
  - `docker-compose.prod.yml`: Production setup (FastAPI + OSRM + Nginx + SSL)

## Architecture

### Data Pipeline

1. **Raw Data Parsing** (`parse.py`):
   - Loads raw pub data from `raw.data` (JSON format with obfuscated field names like `_18`, `_20`, etc.)
   - Extracts essential fields: pub ID, name, address, latitude, longitude
   - Outputs structured pub data to `data.json`
   - Run: `python parse.py`

2. **Distance Precomputation** (`precompute_distances.py`):
   - Loads pub coordinates from `data.json`
   - Queries OSRM's table endpoint to build an n×n distance matrix for all pubs
   - Uses batching (MAX_BATCH_SIZE=10) to handle OSRM's endpoint limits
   - Pickles the distance matrix and metadata to `pub_distances.pkl`
   - Run: `python precompute_distances.py` (requires OSRM server running)

3. **Route Planning** (`planner.py`):
   - Core `PubCrawlPlanner` class that operates on precomputed distances
   - Takes a start point, end point, number of pubs, and uniformity preference
   - Returns optimized routes with pub IDs, total distance, and estimated time

### Route Optimization Strategy

The planner uses a multi-phase approach:

1. **Candidate Selection**: Filters pubs that lie roughly along the corridor from start to end using:
   - `project_onto_line()`: Maps each pub's position onto the start-end line (0-1 scale)
   - `perpendicular_distance()`: Calculates deviation from the path
   - Scores pubs to favor those near the path

2. **Distance Precomputation**: Batch-fetches distances from start/end to all candidates using OSRM

3. **Route Optimization**:
   - **For k ≤ 8 pubs**: Uses sampling + 2-opt (`sample_and_optimize`)
     - Samples 1000 random combinations of k pubs
     - Applies nearest-neighbor ordering + 2-opt local optimization to each
     - Selects the best route
   - **For k > 8 pubs**: Uses greedy with 2-opt (`greedy_with_improvement`)
     - Greedily selects pubs based on distance-to-pub + estimated-distance-to-end
     - Applies 2-opt improvement afterward

4. **Evaluation**: Routes are scored as:
   - `total_distance + uniformity_weight * std_dev_of_segments`
   - Higher `uniformity_weight` (e.g., 0.99) favors evenly-spaced stops

### External Service Integration

**OSRM Client** (`osrm_client.py`):
- Wraps HTTP calls to a local OSRM server (default: `http://localhost:5005`)
- Key methods:
  - `get_distance_matrix()`: Batch query for multiple pairs (most efficient)
  - `get_distances_from_point()`: One-to-many distances
  - `get_distances_to_point()`: Many-to-one distances
  - `get_directions()`: Turn-by-turn navigation with geometry
- **Important**: All coordinates use (longitude, latitude) order, not (lat, lon)

### Data Formats

**Pub Coordinates**: Stored as (longitude, latitude) tuples throughout. This is critical for OSRM compatibility.

**Distance Matrix**: n×n numpy array (float32) indexed by pub indices. Entry `[i][j]` is walking distance in meters from pub i to pub j.

## Quick Start

### Option 1: Full-Stack Development (Recommended)

Start both backend API and frontend development server together:

```bash
# Terminal 1: Start OSRM and FastAPI backend
docker-compose up osrm app

# Terminal 2: Start frontend dev server (from frontend directory)
cd frontend
npm install  # First time only
npm run dev

# Frontend available at http://localhost:5173 (proxies API calls to http://localhost:8000)
# Backend API at http://localhost:8000
# API docs at http://localhost:8000/docs
```

### Option 2: Docker Compose (All Services)

Run everything in containers:

```bash
# Development setup
docker-compose up -d

# Application available at http://localhost:8000
# OSRM accessible at http://localhost:5005
# Check logs: docker-compose logs -f app
```

### Option 3: Backend Only (Quick Testing)

For working on the backend without frontend:

```bash
# Install Python dependencies (requires uv)
cd backend
uv install

# Start OSRM in Docker
docker-compose up -d osrm

# Run FastAPI server
uv run app.py

# Server at http://localhost:8000, docs at http://localhost:8000/docs
```

## Development Commands

### Backend (Python / FastAPI)

**Running the server:**
```bash
cd backend
uv run app.py

# Server runs on http://localhost:8000
# Interactive API docs: http://localhost:8000/docs
# OpenAPI schema: http://localhost:8000/openapi.json
```

**Type checking and linting:**
```bash
cd backend
uv run mypy *.py  # Type check with mypy
```

**Data pipeline scripts:**
```bash
cd backend

# Parse raw pub data (from raw.data) into structured format
uv run parse.py

# Precompute distance matrix (requires OSRM running)
# This creates pub_distances.pkl and takes several minutes
uv run precompute_distances.py
```

**Testing the API directly:**
```bash
# Check API health
curl http://localhost:8000/health

# List available pubs (paginated)
curl http://localhost:8000/pubs?skip=0&limit=10

# Get details for a specific pub
curl http://localhost:8000/pubs/{pub_id}

# Plan a route
curl -X POST http://localhost:8000/plan \
  -H "Content-Type: application/json" \
  -d '{
    "start_point": {"longitude": -2.6, "latitude": 51.4},
    "end_point": {"longitude": -2.5, "latitude": 51.5},
    "num_pubs": 5,
    "uniformity_weight": 0.5
  }'

# Trigger distance precomputation (long-running)
curl -X POST http://localhost:8000/precompute

# Check precomputation status
curl http://localhost:8000/status
```

### Frontend (React / TypeScript / Vite)

**Development:**
```bash
cd frontend

npm install     # Install dependencies
npm run dev     # Start dev server on http://localhost:5173
npm run build   # Build for production (outputs to dist/)
npm run preview # Preview production build locally
```

**Code quality:**
```bash
cd frontend

npm run lint       # Run ESLint
npm run type-check # Type check with TypeScript (tsc)
```

**Frontend dev server proxying:**
The Vite dev server automatically proxies API requests to `http://localhost:8000`. All paths under `/health`, `/pubs`, `/plan`, `/directions`, `/precompute`, `/parse`, and `/status` are forwarded to the backend. This allows development without CORS issues.

### OSRM Server

**Start the OSRM routing backend (required for distance calculations):**
```bash
docker-compose up -d osrm

# Verify it's running
curl http://localhost:5005/route/v1/foot/-2.6,51.4;-2.5,51.4

# View logs
docker-compose logs -f osrm
```

## External Dependencies

### Backend (Python)

**Core dependencies** (specified in `backend/pyproject.toml`):
- **numpy**: Numerical operations on distance matrices
- **requests**: HTTP calls to OSRM
- **tqdm**: Progress bars during precomputation
- **fastapi**: Web framework for the API
- **uvicorn**: ASGI server to run FastAPI
- **pydantic**: Request/response validation and serialization
- **python-dotenv**: Load environment variables from `.env`
- **polyline**: Polyline encoding/decoding for route geometry compression

Install with: `cd backend && uv install` (uses uv package manager)

### Frontend (Node.js)

**Main dependencies** (from `frontend/package.json`):
- **React & React DOM**: UI framework
- **TypeScript**: Type safety
- **Vite**: Build tool and dev server
- **Material-UI**: Component library
- **MapLibre GL**: Interactive maps for route visualization
- **React Icons**: Icon library
- **@mapbox/polyline**: Polyline decoding for efficient route geometry handling

**Development dependencies**:
- **ESLint**: Code quality and style checking
- **TypeScript compiler**: Type checking
- **@types/polyline**: TypeScript types for polyline library

Install with: `cd frontend && npm install`

### System Requirements

- **Node.js** >= 18.x (for frontend development)
- **Python** >= 3.14 (for backend)
- **Docker** & **Docker Compose** (for OSRM and containerized deployments)
- **uv** package manager (lightweight Python package manager, recommended for backend)

## Environment Variables

The application supports configurable data file paths through environment variables. This is useful for:
- Separating data from code in deployments
- Running multiple instances with different datasets
- Simplifying Docker volume configurations

### Configuration Variables

Create a `.env` file in the `backend/` directory or set these environment variables:

```bash
# Data file paths (all optional - defaults shown)
DATA_FILE=data/data.json                       # Path to structured pub data
DISTANCES_FILE=data/pub_distances.pkl          # Path to precomputed distance matrix
RAW_DATA_FILE=data/raw.data                    # Path to raw pub data

# OSRM service
OSRM_URL=http://localhost:5005                 # URL of OSRM routing server
```

### Usage Examples

**Using environment variables with parse.py:**
```bash
cd backend
export DATA_FILE=/data/custom-pubs.json
export RAW_DATA_FILE=/data/raw-pubs.data
uv run parse.py
```

**Using environment variables with precompute_distances.py:**
```bash
cd backend
export DATA_FILE=/data/custom-pubs.json
export DISTANCES_FILE=/data/custom-distances.pkl
export OSRM_URL=http://osrm-server:5005
uv run precompute_distances.py
```

**Running FastAPI server with custom paths:**
```bash
cd backend
export DATA_FILE=/data/custom-pubs.json
export DISTANCES_FILE=/data/custom-distances.pkl
uv run app.py
```

**Docker with volume mounts:**
```bash
docker-compose up -e DATA_FILE=/mounted/data.json -e DISTANCES_FILE=/mounted/distances.pkl
```

## Docker Setup

### Development (docker-compose.yml)

Standard development setup with FastAPI and OSRM:

```bash
# Start OSRM and FastAPI backend
docker-compose up -d osrm app

# Start just OSRM (if you want to run the app locally)
docker-compose up -d osrm

# View logs
docker-compose logs -f app
docker-compose logs -f osrm

# Stop services
docker-compose down

# Rebuild the app image after code changes
docker-compose up -d --build app
```

**Services**:
- **osrm**: OSRM routing backend (port 5005, internal)
  - Routes requests for walking distance calculations
  - Map data from `osrm-data/` directory
  - Auto-restarts on failure

- **app**: FastAPI application (port 8000)
  - Serves REST API and health checks
  - Connects to OSRM via internal network
  - Has healthcheck configured (checks `/health` endpoint)
  - Auto-restarts on crash or unhealthy status

### Production (docker-compose.prod.yml)

Production setup with FastAPI, OSRM, and Nginx with SSL/TLS:

```bash
# Start all production services
docker-compose -f docker-compose.prod.yml up -d

# View logs
docker-compose -f docker-compose.prod.yml logs -f nginx
docker-compose -f docker-compose.prod.yml logs -f app

# Stop services
docker-compose -f docker-compose.prod.yml down
```

**Additional services**:
- **nginx**: Reverse proxy and web server (port 80, 443)
  - Serves static frontend files (dist/)
  - Proxies API calls to FastAPI backend
  - Handles SSL/TLS termination
  - Auto-restarts on crash or unhealthy status

### Data Persistence & Volume Mounting

Both `docker-compose.yml` and `docker-compose.prod.yml` mount the `data/` directory to `/app/data` inside the container. This approach:
- Separates code from data, improving deployment flexibility
- Keeps paths consistent across development and production
- Makes data files accessible from both container and host

**Volume configuration**:
```yaml
volumes:
  - ./data:/app/data                # Data directory
  - ./init-precompute.sh:/init-precompute.sh
```

**Files within the mounted volume**:
- `data.json`: Structured pub data (generated by `/parse` endpoint)
- `pub_distances.pkl`: Precomputed distance matrix (generated by `/precompute` endpoint)
- `raw.data`: Raw pub data file (optional, for manual parsing)

**Inside the container**, all files are accessed via environment variables:
- `DATA_FILE=/app/data/data.json`
- `DISTANCES_FILE=/app/data/pub_distances.pkl`
- `RAW_DATA_FILE=/app/data/raw.data`

To regenerate data, use the API endpoints:
- `POST /parse`: Parse raw data into data.json
- `POST /precompute`: Precompute distance matrix (long-running)

### Startup Flow

When the app container starts (via `entrypoint.sh`):
1. FastAPI server is launched in the background
2. `init-precompute.sh` is executed to ensure the distance matrix exists
3. The script checks if `$DISTANCES_FILE` (from environment variables) exists
4. If the file doesn't exist, precomputation is triggered automatically via the `/precompute` API endpoint
5. Once initialization completes, the app is ready to handle requests

**Note**: The volume mount ensures that precomputed data persists on the host even after the container stops.

## Key Design Decisions

1. **Two-phase distance retrieval**:
   - Precomputed pub-to-pub matrix (fast, reusable)
   - Runtime OSRM calls for start/end to pubs (necessary because start/end can be arbitrary coordinates)

2. **Optimization threshold at 8 pubs**:
   - Below 8: Exhaustive sampling with local optimization is feasible
   - Above 8: Greedy approach with local polish is more practical

3. **Uniformity weighting**:
   - Optional parameter allows trading distance optimality for more even spacing
   - Useful for social crawls where consistent rest intervals matter

## API Architecture

The FastAPI implementation (`app.py`) wraps the core planner logic with HTTP endpoints. The app initializes via a `PubCrawlPlannerApp` class that manages lifecycle, endpoints, and state.

### Global State Management
- `planner`: Singleton `PubCrawlPlanner` instance initialized on startup from `pub_distances.pkl`
- `pubs_data`: In-memory list of `PubModel` objects loaded from `data.json`
- `osrm_client`: Singleton `OSRMClient` for runtime distance queries and directions
- `precompute_in_progress`: Boolean flag to prevent concurrent precomputation requests

### API Endpoints

**Data & Planning**:
- `GET /health`: Check API status and OSRM availability
- `GET /pubs`: List all pubs (supports pagination with `skip` and `limit` query params)
- `GET /pubs/{pub_id}`: Get details for a specific pub
- `POST /plan`: Plan an optimized pub crawl route (main endpoint)
- `POST /directions`: Get turn-by-turn directions for a route
- `GET /status`: Check precomputation status

**Administration**:
- `POST /precompute`: Trigger distance matrix precomputation (long-running, returns job status)
- `POST /parse`: Parse raw pub data from `raw.data` into `data.json`

**Frontend**:
- `GET /`: Serve `index.html`
- `GET /styles.css`: Serve stylesheet
- `GET /app.js`: Serve frontend JavaScript
- `GET /static/*`: Serve static files (if directory exists)

### Request Lifecycle
1. Client sends POST to `/plan` with `PlanCrawlRequest` (start point, end point, num_pubs, uniformity_weight)
2. Pydantic models validate and parse the JSON request
3. Planner computes route using cached distance matrix and OSRM for start/end distances
4. Response includes route indices, pub details, distances, time estimates, and optional leg-by-leg directions
5. FastAPI serializes response to JSON with snake_case field names

### Coordinate Handling in API
- Clients send coordinates as `CoordinateModel` objects with `longitude` and `latitude` fields
- Stored as tuples in (longitude, latitude) order throughout for OSRM compatibility
- **Route geometry encoding**: Direction geometries are encoded as polyline strings for efficient transmission
  - Backend encodes GeoJSON coordinates to polyline format using `polyline_utils.encode_polyline()`
  - Frontend decodes polyline strings to coordinates using `@mapbox/polyline` library
  - Reduces payload size compared to raw coordinate arrays

## Code Style Notes

- Coordinates are consistently (longitude, latitude)
- The planner uses both pub indices (for matrix lookups) and 'start'/'end' markers for start/end points
- Distance values are in meters
- Time estimates assume ~80 meters/minute walking speed
- API responses use snake_case field names (Pydantic default)

## Important Implementation Details

### Distance Matrix Caching
The precomputed distance matrix (`pub_distances.pkl`) contains:
- `distances`: numpy float32 array of shape (n_pubs, n_pubs)
- `pub_coords`: List of (longitude, latitude) tuples for each pub
- `pub_ids`: List of pub ID strings matching the order of the matrix

This matrix is loaded at API startup. If it doesn't exist, the `/precompute` endpoint must be called first (requires OSRM running). The distance values are in meters.

### OSRM Integration Points
- **Precomputation**: Queries all pub-to-pub distances in batches (MAX_BATCH_SIZE=10)
- **Runtime**: Called for start→all_candidates and all_candidates→end distances
- **Directions**: Called to get turn-by-turn routing when `include_directions=true` in `/plan` request
- Coordinate order critical: Always (longitude, latitude) for OSRM endpoints

### Optimization Algorithm Selection
The route optimization strategy depends on the number of pubs:
- **k ≤ 8 pubs**: Full combinatorial search with sampling (1000 samples, 2-opt polish)
  - Finding global optima is feasible; explores distance + uniformity trade-off
- **k > 8 pubs**: Greedy selection with 2-opt improvement
  - Speed required; uses heuristic distance-to-pub + estimated-distance-to-end scoring

The threshold of 8 pubs balances exploration time with solution quality. Adjust in `planner.py:plan_crawl()` if needed.

### Pub Data Structure
Each pub (`PubModel`) has:
- `id`: Unique identifier (string)
- `name`: Display name
- `address`: Street address
- `longitude`, `latitude`: Coordinates for routing
- (optionally) `category`, `description`, etc. from raw data

The `data.json` file stores all pubs as a JSON array. Raw data parsing (`parse.py`) extracts only essential routing fields from obfuscated `raw.data`.

### Route Geometry Encoding
To reduce payload size for direction responses, route geometries are encoded as polyline strings:

**Backend** (`polyline_utils.py`):
- `encode_polyline()`: Converts (lng, lat) coordinate arrays to polyline strings with precision=5
- Used in `app.py` when building `RouteLegModel` responses
- Stores encoded string in `geometry_encoded` field instead of raw geometry

**Frontend** (`src/utils/polyline.ts`):
- `decode_polyline()`: Converts polyline strings back to (lng, lat) coordinate arrays
- Used by Map components to render route visualizations
- Uses `@mapbox/polyline` library for decoding

**Benefits**:
- Typical ~80% reduction in geometry payload size
- Maintains sufficient precision for mapping (5 decimal places ≈ 1 meter accuracy)
- Standard format compatible with MapBox and other routing services

## Shareable Routes Feature

Routes are automatically stored and can be shared with others via unique URLs. When a user plans a route via `POST /plan`, the route is automatically saved to the database with a unique share ID, allowing instant sharing without additional API calls.

### Architecture

**URL Format**: `/routes/{shareId}` (e.g., `https://example.com/routes/01kayhjx`)

**Share IDs**: Generated using ULID (Universally Unique Lexicographically Sortable Identifier)
- 8-character alphanumeric codes
- Sortable by timestamp
- Collision-resistant
- URL-friendly

**TTL (Time-to-Live)**: 30 days
- Routes automatically expire after 30 days
- Cleanup job runs every 60 minutes to remove expired routes
- Early deletion available via DELETE endpoint

### Automatic Route Storage

When `/plan` endpoint is called:
1. Route is optimized and planned
2. Route is **automatically stored** in the database with generated `share_id`
3. `share_id` is returned in the response
4. Frontend immediately redirects to `/routes/{shareId}` for sharing

### Database Schema

**Table**: `shared_routes` (SQLite database in `/app/data/shared_routes.db`)

```sql
share_id (String, PK)         -- 8-char ULID (unique, indexed)
created_at (DateTime)         -- Timestamp of creation
expires_at (DateTime)         -- created_at + 30 days
last_accessed_at (DateTime)   -- Updated each time route is accessed

start_longitude (Float)       -- Start location
start_latitude (Float)
end_longitude (Float)         -- End location
end_latitude (Float)

route_indices (Text JSON)     -- Route as JSON array (e.g., ["start", 0, 5, 12, "end"])
selected_pub_ids (Text JSON)  -- Pub IDs in order as JSON array
legs_geometry_encoded (Text JSON) -- Encoded polyline geometries for each leg

num_pubs (Integer)            -- Number of pubs in route
uniformity_weight (Float)     -- Uniformity preference parameter
total_distance_meters (Float) -- Total distance in meters
estimated_time_minutes (Float)-- Estimated time in minutes
```

### API Endpoints

**Plan a Route (Automatic Storage)**
```http
POST /plan
Content-Type: application/json

{
  "start_point": {"longitude": -2.6, "latitude": 51.4},
  "end_point": {"longitude": -2.5, "latitude": 51.5},
  "num_pubs": 3,
  "uniformity_weight": 0.5,
  "include_directions": true
}

Response (200):
{
  "route_indices": ["start", 0, 5, 12, "end"],
  "pubs": [...],
  "total_distance_meters": 2150.5,
  "estimated_time_minutes": 26.9,
  "num_pubs": 3,
  "legs": [...],  -- With encoded geometries if include_directions=true
  "share_id": "01kayhjx"  -- Automatically generated and stored!
}
```
The route is automatically stored in the database. Frontend redirects to `/routes/{share_id}` immediately.

**Retrieve a Shared Route**
```http
GET /api/routes/{shareId}

Response (200):
{
  "share_id": "01kayhjx",
  "share_url": "https://example.com/routes/01kayhjx",
  "created_at": "2025-11-25T10:30:00",
  "expires_at": "2025-12-25T10:30:00",
  "start_point": {"longitude": -2.6, "latitude": 51.4},
  "end_point": {"longitude": -2.5, "latitude": 51.5},
  "route_indices": ["start", 0, 5, 12, "end"],
  "selected_pub_ids": ["pub_123", "pub_456", "pub_789"],
  "num_pubs": 3,
  "uniformity_weight": 0.5,
  "total_distance_meters": 2150.5,
  "estimated_time_minutes": 26.9,
  "legs": [  -- Includes encoded polyline geometries
    {
      "from_index": 0,
      "to_index": 1,
      "distance_meters": 500,
      "duration_seconds": 375,
      "geometry_encoded": "..."
    },
    ...
  ],
  "pubs": [  -- Full pub details
    {
      "index": 0,
      "pub_id": "pub_123",
      "pub_name": "The Rose",
      "longitude": -2.603,
      "latitude": 51.433
    },
    ...
  ]
}

Error responses:
- 404: Route not found
- 410: Route has expired (automatically deleted)
```

**Delete a Shared Route (Early Expiration)**
```http
DELETE /routes/{shareId}

Response (200):
{
  "status": "deleted",
  "share_id": "01kayhjx"
}

Error responses:
- 404: Route not found
```

### Implementation Details

**Automatic Route Storage in `/plan`** (`app.py:plan_crawl`):
- After route optimization completes
- Calls `_store_route_in_database()` with route details and encoded geometries
- Generates unique 8-character ULID share ID
- Stores route with 30-day expiration
- Returns `share_id` in response (failures logged but don't block request)

**Database Initialization** (`app.py:_lifespan`):
- Creates `shared_routes` table on startup using SQLAlchemy
- Uses SQLite at `/app/data/shared_routes.db` (mounted Docker volume for persistence)
- Configurable via `DATABASE_URL` environment variable

**Cleanup Task** (`app.py:_cleanup_expired_routes`):
- Background asyncio task running every 60 minutes
- Queries for routes where `expires_at < current_time`
- Deletes expired routes from database
- Logs number of routes deleted

**Request Handling**:
- `/plan`: Automatically stores route, returns `share_id`
- `/api/routes/{shareId}`: Retrieves stored route, validates expiration, updates `last_accessed_at`, includes full pub details and encoded geometries
- `/routes/{shareId}`: DELETE to remove route early
- `/routes/{shareId}`: GET to retrieve (API endpoint, for browser navigation use `/routes/{shareId}` SPA route)

### Frontend Integration

**Automatic Share Flow**:
1. User plans route using `/plan` endpoint
2. Backend automatically stores route and returns `share_id`
3. Frontend **immediately redirects** to `/routes/{share_id}` (no user action needed)
4. React Router handles the `/routes/:shareId` path
5. SharedRoute component fetches route data from `/api/routes/{shareId}`
6. User sees populated route and can copy share link using Share button

**Shared Route Display**:
1. User visits `/routes/{shareId}` (via shared link or direct URL)
2. Nginx serves `index.html` (SPA routing)
3. React Router loads SharedRoute component
4. Component fetches route data from `/api/routes/{shareId}` (Accept: application/json header)
5. Nginx proxies API request to FastAPI
6. Map renders the route with encoded geometries decoded from polylines
7. Route is read-only, showing live data from database

### Security & Privacy Considerations

- **No Authentication**: Routes are public and accessible by URL alone
- **Privacy by Obscurity**: Share IDs are random and difficult to guess
- **Rate Limiting**: Optional - can be added to prevent share creation spam
- **Data Retention**: Automatic cleanup after 30 days prevents indefinite storage
- **No Personal Data**: Routes only store location and pub selections, no user info

### Environment Variables

```bash
DATABASE_URL=sqlite:////app/data/shared_routes.db    # SQLAlchemy database URL
```

**Docker Compose Configuration**:
- `DATABASE_URL` is set to `sqlite:////app/data/shared_routes.db` in both `docker-compose.yml` and `docker-compose.prod.yml`
- The `/app/data` directory is mounted as a Docker volume (`./data:/app/data`) for persistence
- Database file persists on the host machine at `./data/shared_routes.db`

Examples:
```bash
# Use SQLite (default in Docker)
export DATABASE_URL="sqlite:////app/data/shared_routes.db"

# Use PostgreSQL
export DATABASE_URL="postgresql://user:password@localhost/crawl_planner"

# Use MySQL
export DATABASE_URL="mysql+pymysql://user:password@localhost/crawl_planner"
```

**Inspecting the Database**:
```bash
# Connect to SQLite database in running container
docker-compose exec app sqlite3 /app/data/shared_routes.db

# Example queries
SELECT share_id, created_at, num_pubs FROM shared_routes;
SELECT share_id, expires_at FROM shared_routes WHERE expires_at > datetime('now');
```

## Frontend Architecture

The frontend is a React + TypeScript application built with Vite. It provides an interactive UI for planning pub crawl routes.

### Key Components

**Main Application** (`src/App.tsx`):
- Top-level React component that manages application state
- Orchestrates the map, form, results, and UI layout

**Components** (`src/components/`):
- **Map components**: Interactive MapLibre GL maps for showing route visualization
- **Form components**: Inputs for start location, end location, number of pubs, and uniformity preference
- **Results components**: Display planned routes with distances, times, and pub details
- **Dialog/Modal components**: Confirmation and informational dialogs

**Services** (`src/services/`):
- **API client**: Handles HTTP calls to the FastAPI backend
- **Distance/routing services**: Wrapper functions for route planning, directions, and pub listing

**Hooks** (`src/hooks/`):
- Custom React hooks for state management, API calls, and side effects
- Encapsulate reusable logic

**Utilities** (`src/utils/`):
- Helper functions for calculations, formatting, and data transformation
- Map utilities for coordinate handling

**Theme & Styling** (`src/theme.ts`):
- Material-UI theme configuration
- Global color, typography, and spacing definitions
- Emotion CSS-in-JS for component styling

### Key Design Patterns

- **State Management**: Uses React hooks (useState, useEffect, useReducer) for component state
- **API Integration**: Axios or Fetch API via custom service functions
- **Error Handling**: Toast notifications or dialog modals for user feedback
- **Responsive Design**: Material-UI components and CSS media queries for mobile/tablet/desktop layouts
- **Map Rendering**: MapLibre GL for displaying Bristol map with route polylines and pub markers
